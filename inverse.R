## Creates a special 'matrix' object, that can cache its inverse.

makeCacheMatrix<- function(x=matrix()) {        # the input x is an invertible matrix
    inv<-NULL                                   # initializes inverse matrix
    set<- function(y) {                         # takes an input matrix (invertible)
        x<<-y                                   # saves the input matrix
        inv<<-NULL                              # resets inverse matrix 
    }
    get<- function() x                                  # returns the value of the original matrix                    
    setinv<- function(solve) inv<<-solve                # called by cachesolve() during the first cachesolve() access, it calculates inverse matrix and stores the value
    getinv<- function() inv                             # returns the cached value to cachesolve() on subsequent accesses
    
    list(set=set,get=get,setinv=setinv,getinv=getinv)   # list with internal functions generated by calling makeCacheMatrix()
}



## If the inverse matrix has already been calculated it gets the inverse from the 
## cache and skips the computation.
## Otherwise, it calculates the inverse of the data and sets the value of the inverse
## in the cache via the setinv function.

cachesolve<-function(x,...) {             # the input x is an object created by makeCacheMatrix
    inv<-x$getinv()                       # accesses the object 'x' and gets the value of the inverse matrix
    if(!is.null(inv)) {                   # if inverse was already cached...
        message("getting cached data")    # shows message and returns cached inverse 
        return(inv)
    }
                                          # if x$getinv() returned NULL (first call)
    data<-x$get()                         
    inv<-solve(data,...)                  # calculates inverse matrix
    x$setinv(inv)                         # stores it in x 
    inv                                   # returns inverse matrix
}

